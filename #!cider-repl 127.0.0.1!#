; CIDER 0.7.0 (Java 1.7.0_25, Clojure 1.6.0, nREPL 0.2.6, cider-nrepl 0.7.0)
four-clojure.core> (def a [2 3 3 4 5])
#'four-clojure.core/a
four-clojure.core> a
[2 3 3 4 5]
four-clojure.core> ((fn [a b] a) [1 2 3])
ArityException Wrong number of args (1) passed to: core/eval3531/fn--3532  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> ((fn [[a b]] a) [1 2 3])
1
four-clojure.core> ((fn [[a b]] b) [1 2 3])
2
four-clojure.core> ((fn [[a &b]] b) [1 2 3])
CompilerException java.lang.RuntimeException: Unable to resolve symbol: b in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:2) 
four-clojure.core> ((fn [[a & b]] b) [1 2 3])
(2 3)
four-clojure.core> ((fn [[a & b]] [a b]) [1 2 3])
[1 (2 3)]
four-clojure.core> ((fn [a & b] [a b]) [1 2 3])
[[1 2 3] nil]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a)
    []))
#'four-clojure.core/drill
four-clojure.core> (drill (range 9))
[7 6 5 4 3 2 1 0]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a)
    [a]))

#'four-clojure.core/drill
four-clojure.core> (drill (range 9))
[8 7 6 5 4 3 2 1 0]
four-clojure.core> (drill a)
[3 2]
four-clojure.core> (defn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse (drill coll)))
    []))
#'four-clojure.core/p60
four-clojure.core> (P60 a)
CompilerException java.lang.RuntimeException: Unable to resolve symbol: P60 in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (p60 a)
[(5) (4 5) (3 4 5) (3) (2 3)]
four-clojure.core> (def b *1)
#'four-clojure.core/b
four-clojure.core> (sort count b)
ArityException Wrong number of args (2) passed to: core/count  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (sort #(count %) b)
ArityException Wrong number of args (2) passed to: core/eval3586/fn--3587  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (sort #(> (count %)) b)
ArityException Wrong number of args (2) passed to: core/eval3591/fn--3592  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (sort-by count b)
((5) (3) (4 5) (2 3) (3 4 5))
four-clojure.core> (last *1)
(3 4 5)
four-clojure.core> (defn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    []))
#'four-clojure.core/p60
four-clojure.core> (p60 a)
[(5) (4 5) (3 4 5) (3) (2 3)]
four-clojure.core> (defn drill
  [[a & coll]]
  a)

#'four-clojure.core/drill
four-clojure.core> (p60 a)
[(5) (4 5) (3 4 5) (3) (2 3)]
four-clojure.core> (last (sort-by count (p60 a)))
(3 4 5)
four-clojure.core> (last (sort-by count (p60  [1 0 1 2 3 0 4 5])))
(0 1 2 3)
four-clojure.core> (last (sort-by count (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    []))))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3615$p60__3616  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (last (sort-by count (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    []))))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3623$p60__3624  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> ((last (sort-by count (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    [])))) a)
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3631$p60__3632  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    []))
#<core$eval3639$p60__3640 four_clojure.core$eval3639$p60__3640@64424952>
four-clojure.core> (last (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll)) (reverse ((fn drill
                                        [[a & coll]]
                                        (if (= (inc a) (first coll))
                                          (conj (drill coll) a)
                                          [a])) coll)))
    [])))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3647$p60__3648  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (fn [a] (-> a
			       (fn p60
				 [coll]
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
			       (sort-by count)
			       last))
CompilerException java.lang.IllegalArgumentException: Parameter declaration p60 should be a vector, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:2:11) 
four-clojure.core> (fn p60
				 [coll]
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
#<core$eval3657$p60__3658 four_clojure.core$eval3657$p60__3658@587817e4>
four-clojure.core> (fn [a] (-> a
			       (fn p60
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
			       (sort-by count)
			       last))
CompilerException java.lang.IllegalArgumentException: Parameter declaration p60 should be a vector, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:2:11) 
four-clojure.core> (fn [a] (-> a
			       (fn p60
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
			       (sort-by count)
			       last))
CompilerException java.lang.IllegalArgumentException: Parameter declaration p60 should be a vector, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:2:11) 
four-clojure.core> (fn [a] (-> a
			       (fn p60
				 [coll]
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
			       (sort-by count)
			       last))
CompilerException java.lang.IllegalArgumentException: Parameter declaration p60 should be a vector, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:2:11) 
four-clojure.core> (-> [1 2 3 4]
		       apply *)
ArityException Wrong number of args (1) passed to: core/apply  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (-> [1 2 3 4]
		       (apply *))
IllegalArgumentException Don't know how to create ISeq from: clojure.core$_STAR_  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (-> [1 2 3 4]
		       first)
1
four-clojure.core> (-> [1 2 3 4]
		       (apply * %))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: % in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:2:10) 
four-clojure.core> (-> [1 2 3 4]
		       #(apply * %))
CompilerException java.lang.IllegalArgumentException: fn params must be Symbols, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (-> [1 2 3 4]
		       apply *)
ArityException Wrong number of args (1) passed to: core/apply  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (apply * [1 2 3 43
			     ])
258
four-clojure.core> (->> [1 2 3 4]
		       apply *)
ArityException Wrong number of args (1) passed to: core/apply  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (->> [1 2 3 4]
		       (apply *))
24
four-clojure.core> (fn [a] (->> a
			       (fn p60
				 [coll]
				 (if (seq coll)
				   (conj (p60 (rest coll)) (reverse ((fn drill
								       [[a & coll]]
								       (if (= (inc a) (first coll))
									 (conj (drill coll) a)
									 [a])) coll)))
				   []))
			       (sort-by count)
			       last))
#<core$eval3689$fn__3690 four_clojure.core$eval3689$fn__3690@1e217f8f>
four-clojure.core> ((fn [a] (->> a
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll)) (reverse ((fn drill
									[[a & coll]]
									(if (= (inc a) (first coll))
									  (conj (drill coll) a)
									  [a])) coll)))
				    []))
				(sort-by count)
				last)) a)
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3699$fn__3700$p60__3701  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (->> a
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll)) (reverse ((fn drill
									[[a & coll]]
									(if (= (inc a) (first coll))
									  (conj (drill coll) a)
									  [a])) coll)))
				    []))
				(sort-by count)
				last)
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3709$p60__3710  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (->> a
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll)) (reverse ((fn drill
									[[a & coll]]
									(if (= (inc a) (first coll))
									  (conj (drill coll) a)
									  [a])) coll)))
				    []))
			        z) )
RuntimeException Unmatched delimiter: )  clojure.lang.Util.runtimeException (Util.java:221)
four-clojure.core> (fn [a] (->> a
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll))
					  (reverse ((fn drill
						      [[a & coll]]
						      (if (= (inc a) (first coll))
							(conj (drill coll) a)
							[a])) coll)))
				    []))) a)
#<core$eval3811$fn__3812 four_clojure.core$eval3811$fn__3812@722da63b>
four-clojure.core> ((fn [a] (->> a
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll))
					  (reverse ((fn drill
						      [[a & coll]]
						      (if (= (inc a) (first coll))
							(conj (drill coll) a)
							[a])) coll)))
				    [])))) a)
#<core$eval3821$fn__3822$p60__3823 four_clojure.core$eval3821$fn__3822$p60__3823@4a229403>
four-clojure.core> ((fn [tot] (->> tot
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll))
					  (reverse ((fn drill
						      [[a & coll]]
						      (if (= (inc a) (first coll))
							(conj (drill coll) a)
							[a])) coll)))
				    [])))) a)
#<core$eval3831$fn__3832$p60__3833 four_clojure.core$eval3831$fn__3832$p60__3833@236a56f1>
four-clojure.core> ((fn [tot] (->> tot
				(fn p60
				  [coll]
				  (if (seq coll)
				    (conj (p60 (rest coll))
					  (reverse ((fn drill
						      [[a & coll]]
						      (if (= (inc a) (first coll))
							(conj (drill coll) a)
							[a])) coll)))
				    []))
				last)) a)
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$eval3841$fn__3842$p60__3843  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (< [1 2 3] [ 12 3])
ClassCastException clojure.lang.PersistentVector cannot be cast to java.lang.Number  clojure.lang.Numbers.lt (Numbers.java:219)
four-clojure.core> (fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll]]
                      (if (= (inc a) (first coll))
                        (conj (drill coll) a)
                        [a])) coll)))
    []))
#<core$eval3853$p60__3854 four_clojure.core$eval3853$p60__3854@6ae97c09>
four-clojure.core> ((fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll]]
                      (if (= (inc a) (first coll))
                        (conj (drill coll) a)
                        [a])) coll)))
    []))a)
[(5) (4 5) (3 4 5) (3) (2 3)]
four-clojure.core> (#((fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll]]
                      (if (= (inc a) (first coll))
                        (conj (drill coll) a)
                        [a])) coll)))
    []))%) a)
[(5) (4 5) (3 4 5) (3) (2 3)]
four-clojure.core> (#(sort-by count ((fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll]]
                      (if (= (inc a) (first coll))
                        (conj (drill coll) a)
                        [a])) coll)))
    []))%)) a)
((5) (3) (4 5) (2 3) (3 4 5))
four-clojure.core> (#(last (sort-by count ((fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll]]
                      (if (= (inc a) (first coll))
                        (conj (drill coll) a)
                        [a])) coll)))
    []))%))) a)
(3 4 5)
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a)
    [a]))
#'four-clojure.core/drill
four-clojure.core> (drill a)
[3 2]
four-clojure.core> (drill [1 2 3 3 2 1])
[3 2 1]
four-clojure.core> (drill [2 1 2 3 3 2 1])
[2]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a b)
    []))
#'four-clojure.core/drill
four-clojure.core> (drill [2 1 2 3 3 2 1])
[]
four-clojure.core> (drill [ 1 2 3 3 2 1])
[2 [(5) (4 5) (3 4 5) (3) (2 3)] 1 [(5) (4 5) (3 4 5) (3) (2 3)]]
four-clojure.core> (defn drill
  [[a b & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a b)
    []))
#'four-clojure.core/drill
four-clojure.core> (drill [ 1 2 3 3 2 1])
[]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) (first coll))
    [a]))
#'four-clojure.core/drill
four-clojure.core> (drill [ 1 2 3 3 2 1])
[3 3 2]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) (first coll))
    []))
#'four-clojure.core/drill
four-clojure.core> (drill [ 1 2 3 3 2 1])
[3 2]
four-clojure.core> (defn drill
  [[a & coll]]
  (if (= (inc a) (first coll))
    (conj (drill coll) a (first coll))
    []))
#'four-clojure.core/drill
four-clojure.core> (drill [ 1 2 3 3 2 1])
[2 3 1 2]
four-clojure.core> (drill [ 2 1 2 3 3 2 1])
[]
four-clojure.core> (defn drill
  [[a & coll] x]
  (if (= (inc a) (first coll))
    (conj (drill coll (conj x a)) a)
    (if (first x)[a])))
#'four-clojure.core/drill
four-clojure.core> (defn drill
  [[a & coll] x]
  (if (= (inc a) (first coll))
    (conj (drill coll (conj x a)) a)
    (if (first x)
      [a]
      [])))
#'four-clojure.core/drill
four-clojure.core> (drill [ 2 1 2 3 3 2 1])
ArityException Wrong number of args (1) passed to: core/drill  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (drill [ 2 1 2 3 3 2 1] [])
[]
four-clojure.core> (drill [1 2 3 3 2 1] [])
[3 2 1]
four-clojure.core> (#(last (sort-by count ((fn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse (fn drill
                     [[a & coll] x]
                     (if (= (inc a) (first coll))
                       (conj (drill coll (conj x a)) a)
                       (if (first x)
                         [a]
                         []))) coll [])))
    [])%))) a)
ArityException Wrong number of args (3) passed to: core/reverse  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (#(last (sort-by count ((fn p60
					     [coll]
					     (if (seq coll)
					       (conj (p60 (rest coll))
						     (reverse (fn drill
								[[a & coll] x]
								(if (= (inc a) (first coll))
								  (conj (drill coll (conj x a)) a)
								  (if (first x)
								    [a]
								    []))) coll []))
					       [])%)))) a)
ArityException Wrong number of args (0) passed to: core/eval3964/fn--3965/p60--3966  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (defn p60
  [coll]
  (if (seq coll)
    (conj (p60 (rest coll))
          (reverse ((fn drill
                      [[a & coll] x]
                      (if (= (inc a) (first coll))
                        (conj (drill coll (conj x a)) a)
                        (if (first x)
                          [a]
                          []))) coll [])))
    []))
#'four-clojure.core/p60
four-clojure.core> (p60 a)
[() (4 5) (3 4 5) () (2 3)]
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      [])))

#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [2 3 4])
[4 3 2]
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [2 3 4])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (p53 * 2 [2 3 4])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (p53 * 2 [ 1 2 3])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    x2))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 1 2 3])
2
four-clojure.core> (p53 * 2 [ 5 2 3])
10
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      "a")))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    x2))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
10
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (seq [])
nil
four-clojure.core> (seq [1])
(1)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj [1] x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (seq [1])
(1)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x2 (rest y)) x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj [1] x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
[1 10]
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq y)
      (conj (p53 f x (next y)) x2)
      [])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq (next y))
      (conj (p53 f x (next y)) x2)
      [x2])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
[6 4 10]
four-clojure.core> (defn p53
  [f x y]
  (let [x2 (f x (first y))]
    (if (seq (next y))
      (conj (p53 f x2 (next y)) x2)
      [x2])))
#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [ 5 2 3])
[60 20 10]
four-clojure.core> (p53 * 2 [1 2 3])
[12 4 2]
four-clojure.core> (p53 * 2 [3 4 5])
[120 24 6]
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (let [x2 (f x (first y))]
       (if (seq (next y))
         (conj (p53 f x2 (next y)) x2)
         [x2]))))

#'four-clojure.core/p53
four-clojure.core> (p53 * 2 [1 2 3])
[12 4 2]
four-clojure.core> (p53 *  [1 2 3])
[6 2]
four-clojure.core> (p53 conj [1]  [1 2 3])
[[1 1 2 3] [1 1 2] [1 1]]
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (let [x2 (f x (first y))]
       (if (seq (next y))
         (conj (p53 f x2 (next y)) x)
         [x2]))))

#'four-clojure.core/p53
four-clojure.core> (p53 conj [1]  [1 2 3])
[[1 1 2 3] [1 1] [1]]
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (let [x2 (f x (first y))]
       (if (seq (next y))
         (conj (p53 f x2 (next y)) x)
         [x]))))

#'four-clojure.core/p53
four-clojure.core> (p53 conj [1]  [1 2 3])
[[1 1 2] [1 1] [1]]
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
       (if (seq y)
         (conj (p53 f (f x (first y)) (next y)) x)
         [x])))

#'four-clojure.core/p53
four-clojure.core> (p53 conj [1]  [1 2 3])
[[1 1 2 3] [1 1 2] [1 1] [1]]
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (conj (p53 f (f x (first y)) (next y)) x)
       [x])))

#'four-clojure.core/p53
four-clojure.core> (p53 conj [1]  [1 2 3])
[[1 1 2 3] [1 1 2] [1 1] [1]]
four-clojure.core> (p53 + (range 10))
[45 36 28 21 15 10 6 3 1 0]
four-clojure.core> (take 5(p53 + (range)))
StackOverflowError   clojure.core/+ (core.clj:951)
four-clojure.core> (take 5 (p53 + (range)))
StackOverflowError   clojure.lang.LazySeq.sval (LazySeq.java:40)
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (conj (lazy-seq (p53 f (f x (first y))) (next y)) x)
       (lazy-seq [x]))))

#'four-clojure.core/p53
four-clojure.core> (take 5 (p53 + (range)))
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (lazy-seq 1)
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (lazy-seq [1])
(1)
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (conj (lazy-seq (p53 f (f x (first y))) (next y)) x)
       (lazy-seq [x]))))

#'four-clojure.core/p53
four-clojure.core> (take 5 (p53 + (range)))
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (if (seq range)
		     (take 5 range))
IllegalArgumentException Don't know how to create ISeq from: clojure.core$range  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (take 5 range)
IllegalArgumentException Don't know how to create ISeq from: clojure.core$range  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (take 5 (range))
(0 1 2 3 4)
four-clojure.core> (if (seq (range))
		     (take 5 (range)))
(0 1 2 3 4)
four-clojure.core> (take 5 (p53 + [1 2 3]))
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (conj (p53 f (f x (first y)) (next y)) x)
       [x])))

#'four-clojure.core/p53
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (cons x (p53 f (f x (first y)) (next y)))
       [x])))

#'four-clojure.core/p53
four-clojure.core> (take 5 (p53 + [1 2 3]))
(1 3 6)
four-clojure.core> (take 5 (p53 + (range)))
StackOverflowError   clojure.lang.RT.first (RT.java:577)
four-clojure.core> (defn p53
  ([f x]
     (p53 f (first x) (rest x)))
  
  ([f x y]
     (if (seq y)
       (cons x (lazy-seq (p53 f (f x (first y)) (next y))))
       [x])))

#'four-clojure.core/p53
four-clojure.core> (take 5 (p53 + (range)))
(0 1 3 6 10)
four-clojure.core> (take 5 (p53 + (range)))
(0 1 3 6 10)
four-clojure.core> (p53 conj [0] [1 2 3])
([0] [0 1] [0 1 2] [0 1 2 3])
four-clojure.core> (str 121)
"121"
four-clojure.core> (split-at 2)
ArityException Wrong number of args (1) passed to: core/split-at  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (split-at *1 2)
ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.isPos (Numbers.java:94)
four-clojure.core> (split-at 2 *1)
[(\1 \2) (\1)]
four-clojure.core> (quot 12345 100)
123
four-clojure.core> (rem 12345 100)
45
four-clojure.core> (rem 12345 1000)
345
four-clojure.core> (str 112345)
"112345"
four-clojure.core> (count *1)
6
four-clojure.core> (str 112345)
"112345"
four-clojure.core> (split-at 3 *1)
[(\1 \1 \2) (\3 \4 \5)]
four-clojure.core> (odd? 4)
false
four-clojure.core> (odd? 3)
true
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)]
    (if (odd? c)
      [l r]
      [l r])))

#'four-clojure.core/p115
four-clojure.core> (p115 12345)
[(\1 \2) (\3 \4 \5)]
four-clojure.core> (reduce #(+ (int %1) (int %2)) (\3 \4 \5))
ClassCastException java.lang.Character cannot be cast to clojure.lang.IFn  four-clojure.core/eval4132 (form-init1677612859217766242.clj:1)
four-clojure.core> (int \3)
51
four-clojure.core> (reduce #(+ (int %) 0
			       (\3 \4 \5)))
ArityException Wrong number of args (1) passed to: core/reduce  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (int %)) 0 (\3 \4 \5)))
ClassCastException java.lang.Character cannot be cast to clojure.lang.IFn  four-clojure.core/eval4144 (form-init1677612859217766242.clj:1)
RuntimeException Unmatched delimiter: )  clojure.lang.Util.runtimeException (Util.java:221)
four-clojure.core> (reduce #(+ (int %) 0)  (\3 \4 \5)))
ClassCastException java.lang.Character cannot be cast to clojure.lang.IFn  four-clojure.core/eval4149 (form-init1677612859217766242.clj:1)
RuntimeException Unmatched delimiter: )  clojure.lang.Util.runtimeException (Util.java:221)
four-clojure.core> (reduce #(+ (int %) 0)  (\3 \4 \5))
ClassCastException java.lang.Character cannot be cast to clojure.lang.IFn  four-clojure.core/eval4154 (form-init1677612859217766242.clj:1)
four-clojure.core> (reduce #(+ (int %) 0) '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4159/fn--4160  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (int %)) 0 '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4164/fn--4165  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (int %)) '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4169/fn--4170  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (int 1) (int %2)) '(\3 \4 \5))
54
four-clojure.core> (int \3)
51
four-clojure.core> (num \3)
ClassCastException java.lang.Character cannot be cast to java.lang.Number  clojure.lang.Numbers.num (Numbers.java:1328)
four-clojure.core> (read-string \3)
ClassCastException java.lang.Character cannot be cast to java.lang.String  clojure.core/read-string (core.clj:3497)
four-clojure.core> (reduce #(+ (int 1) (int %2)) '(\3 \4 \5))
54
four-clojure.core> (int \4)
52
four-clojure.core> (int \5)
53
four-clojure.core> (reduce #(+ (int %1) (int %2)) '(\3 \4 \5))
156
four-clojure.core> (reduce #(+ (- (int %) 48)) '(\3 \4 \5))
-36
four-clojure.core> (reduce #(+ (- (int %) 48)) '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4208/fn--4209  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (- (int %) 48)) 0 '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4213/fn--4214  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partia l+ (- (int %) 48)) 0 '(\3 \4 \5))
CompilerException java.lang.RuntimeException: Unable to resolve symbol: partia in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:10) 
four-clojure.core> (reduce #(partial + (- (int %) 48)) 0 '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4221/fn--4222  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial + (- (int %) 48)) '(\3 \4 \5))
ArityException Wrong number of args (2) passed to: core/eval4226/fn--4227  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ (int %1) (int %2)) '(\3 \4 \5))
156
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (map int coll))]
    (if (odd? c)
      (f l)
      (f r))))

#'four-clojure.core/p115
four-clojure.core> (p115 12345)
(49 50)
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (- (reduce #(+ (int %1) (int %2)) coll) (* 48 (count coll))))]
    (if (odd? c)
      (f l)
      (f r))))
#'four-clojure.core/p115
four-clojure.core> (p115 12345)
3
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (- (reduce #(+ (int %1) (int %2)) coll) (* 48 (count coll))))]
    (if (odd? c)
      (= (f l) (f (rest r)))
      (= (f l) (f r)))))

#'four-clojure.core/p115
four-clojure.core> (p115 12345)
false
four-clojure.core> (p115 12303)
true
four-clojure.core> (p115 12)
ClassCastException java.lang.Character cannot be cast to java.lang.Number  clojure.lang.Numbers.minus (Numbers.java:135)
four-clojure.core> (quot 2 2)
1
four-clojure.core> (p115 121)
ClassCastException java.lang.Character cannot be cast to java.lang.Number  clojure.lang.Numbers.minus (Numbers.java:135)
four-clojure.core> (p115 12303)
true
four-clojure.core> (p115 121)
ClassCastException java.lang.Character cannot be cast to java.lang.Number  clojure.lang.Numbers.minus (Numbers.java:135)
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (- (reduce #(+ (int %1) (int %2)) coll) (* 48 (count coll))))]
    (if (odd? c)
      ;;(= (f l) (f (rest r)))
      [l r]
      ;;(= (f l) (f r))
      [l r])))

#'four-clojure.core/p115
four-clojure.core> (p115 121)
[(\1) (\2 \1)]
four-clojure.core> (p115 11)
[(\1) (\1)]
four-clojure.core> (apply + '(\2 \1))
ClassCastException   [trace missing]
four-clojure.core> (reduce + [1])
1
four-clojure.core> (reduce + [1 2])
3
four-clojure.core> (reduce #(partial + (int %)) 0 [1 2 3])
ArityException Wrong number of args (2) passed to: core/eval4323/fn--4324  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial +) 0 [1 2 3])
ArityException Wrong number of args (2) passed to: core/eval4327/fn--4328  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial + % 0)  [1 2 3])
ArityException Wrong number of args (2) passed to: core/eval4332/fn--4333  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial + 0)  [1 2 3])
ArityException Wrong number of args (2) passed to: core/eval4336/fn--4337  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce (partial + 0)  [1 2 3])
6
four-clojure.core> (reduce (partial + %)  [1 2 3 4])
10
four-clojure.core> (reduce (partial + %)  [1 2 3 4])
CompilerException java.lang.RuntimeException: Unable to resolve symbol: % in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:9) 
four-clojure.core> (reduce #(partial + %)  [1 2 3 4])
ArityException Wrong number of args (2) passed to: core/eval4346/fn--4347  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial + %) 0  [1 2 3 4])
ArityException Wrong number of args (2) passed to: core/eval4351/fn--4352  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce (partial + )  [1 2 3 4])
10
four-clojure.core> (reduce (partial + #(int %))  [1 2 3 4])
ClassCastException four_clojure.core$eval4358$fn__4359 cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:126)
four-clojure.core> (reduce + 4  [1 2 3 4])
14
four-clojure.core> (reduce #(+ %) 4  [1 2 3 4])
ArityException Wrong number of args (2) passed to: core/eval4365/fn--4366  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(partial + %) 4  [1 2 3 4])
ArityException Wrong number of args (2) passed to: core/eval4370/fn--4371  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (reduce #(+ %1 %2) 4  [1 2 3 4])
14
four-clojure.core> (reduce #(+ %1 %2) 0  [1 2 3 4])
10
four-clojure.core> (reduce #(+ %1 (- %2 2)) 0  [1 2 3 4])
2
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (- (reduce #(+ (int %)) 0 coll) (* 48 (count coll))))]
    (if (odd? c)
      (= (f l) (f (rest r)))
      (= (f l) (f r)))))
#'four-clojure.core/p115
four-clojure.core> (p115 11)
ArityException Wrong number of args (2) passed to: core/p115/f--4394/fn--4395  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> ((fn [coll] (- (reduce #(+ (int %)) 0 coll) (* 48 (count coll)))) '(\1 \1))
ArityException Wrong number of args (2) passed to: core/eval4402/fn--4403/fn--4404  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> ((fn [coll] (- (reduce #(+ %1 (int 2)) 0 coll) (* 48 (count coll)))) '(\1 \1))
ArityException Wrong number of args (2) passed to: core/eval4409/fn--4410/fn--4411  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> ((fn [coll] (- (reduce #(+ %1 (int %2)) 0 coll) (* 48 (count coll)))) '(\1 \1))
2
four-clojure.core> (defn p115
  [num]
  (let [s (str num)
        c (count s)
        [l r] (split-at (quot c 2) s)
        f (fn [coll] (- (reduce #(+ %1 (int %2)) 0 coll) (* 48 (count coll))))]
    (if (odd? c)
      (= (f l) (f (rest r)))
      (= (f l) (f r)))))
#'four-clojure.core/p115
four-clojure.core> (p115 11)
true
four-clojure.core> (p115 112)
false
four-clojure.core> (p115 111)
true
four-clojure.core> {}
{}
four-clojure.core> (hash-map)
{}
four-clojure.core> (take-while num [1 2 3 4 :a])
ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Number  clojure.lang.Numbers.num (Numbers.java:1328)
four-clojure.core> (take-while int [1 2 3 4 :a])
ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Character  clojure.lang.RT.intCast (RT.java:1087)
four-clojure.core> (take-while number? [1 2 3 4 :a])
(1 2 3 4)
four-clojure.core> (take-while number? [ :a :b 1 2 3 4 :a])
()
four-clojure.core> (take-while keyword? [ :a :b 1 2 3 4 :a])
(:a :b)
four-clojure.core> (defn p105
  [coll]
  (if (seq coll)
    (if (keyword? (first coll))
      (assoc (p105 (rest coll)) (first coll) (take-while number? (rest coll)))
      (p105 (rest coll)))
    {}))

#'four-clojure.core/p105
four-clojure.core> (p105 [:a 1])
{:a (1)}
four-clojure.core> (p105 [:a 1 2 3 4])
{:a (1 2 3 4)}
four-clojure.core> (p105 [:a 1 2 3 4 :b :c])
{:a (1 2 3 4), :b (), :c ()}
four-clojure.core> (p105 [:a 1 2 3 4 :b :c 2 4 5])
{:a (1 2 3 4), :b (), :c (2 4 5)}
four-clojure.core> (identity #{1 2 3})
#{1 3 2}
four-clojure.core> (map identity #{1 2 3})
(1 3 2)
four-clojure.core> (apply identity #{1 2 3})
ArityException Wrong number of args (3) passed to: core/identity  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (take 5 (iterate (* 2 1)))
ArityException Wrong number of args (1) passed to: core/iterate  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (take 5 (iterate (* 2 1) 1))
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  clojure.core/iterate/fn--4304 (core.clj:2723)
four-clojure.core> (take 5 (iterate #(* 2 2) 1))
ArityException Wrong number of args (1) passed to: core/eval4470/fn--4471  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (take 5 (iterate #(* 2 5) 1))
ArityException Wrong number of args (1) passed to: core/eval4474/fn--4475  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (take 5 (iterate #(* 2 %) 1))
(1 2 4 8 16)
four-clojure.core> [#(inc %) #(dec %)]
[#<core$eval4485$fn__4486 four_clojure.core$eval4485$fn__4486@5135b083> #<core$eval4485$fn__4488 four_clojure.core$eval4485$fn__4488@65b97a8b>]
four-clojure.core> (def a[#(inc %) #(dec %)])
#'four-clojure.core/a
four-clojure.core> a
[#<core$fn__4493 four_clojure.core$fn__4493@30d25f2> #<core$fn__4495 four_clojure.core$fn__4495@32ac4cf3>]
four-clojure.core> (map 1 a)
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  clojure.core/map/fn--4245 (core.clj:2557)
four-clojure.core> (map a 1)
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (map a [1 2])
IndexOutOfBoundsException   clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107)
four-clojure.core> (defn p144
  [x & f]
  [x f])

#'four-clojure.core/p144
four-clojure.core> (p144 1 int doucle)
CompilerException java.lang.RuntimeException: Unable to resolve symbol: doucle in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (p144 1 int double)
[1 (#<core$int clojure.core$int@6f156d0c> #<core$double clojure.core$double@6484f8e6>)]
four-clojure.core> [int inc]
[#<core$int clojure.core$int@6f156d0c> #<core$inc clojure.core$inc@3d7c4a8>]
four-clojure.core> (take 5 [int inc])
(#<core$int clojure.core$int@6f156d0c> #<core$inc clojure.core$inc@3d7c4a8>)
four-clojure.core> (take 5 (cycle [int inc]))
(#<core$int clojure.core$int@6f156d0c> #<core$inc clojure.core$inc@3d7c4a8> #<core$int clojure.core$int@6f156d0c> #<core$inc clojure.core$inc@3d7c4a8> #<core$int clojure.core$int@6f156d0c>)
four-clojure.core> (take 5 (cycle [1 3]))
(1 3 1 3 1)
four-clojure.core> (defn p144
  [x & f]
  (fn ocil
    [x f1 & f]
    (cons x (lazy-seq (p144 (f1 x) f)))))
#'four-clojure.core/p144
four-clojure.core> (take 5 (p144 3 inc dec))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$p144$ocil__4515  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (defn p144
  [x & f]
  (fn ocil
    [x f1 & f]
    (if x
      (cons x (lazy-seq (p144 (f1 x) f)))
      [x])))
#'four-clojure.core/p144
four-clojure.core> (take 5 (p144 3 inc dec))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$p144$ocil__4522  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (take 5 (p144 3 (cycle [inc dec])))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$p144$ocil__4522  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (defn p144
  [x & f]
  (fn ocil
    [x f1 & f]
    (if x
      (cons x (lazy-seq (ocil (f1 x) f)))
      [x])))
#'four-clojure.core/p144
four-clojure.core> (take 5 (p144 3 (cycle [inc dec])))
IllegalArgumentException Don't know how to create ISeq from: four_clojure.core$p144$ocil__4531  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (defn p144
  [x & f]
  (fn ocil
    [x f1 & f]
    (if f1
      (cons x (lazy-seq (ocil (f1 x) f)))
      [x])))

#'four-clojure.core/p144
four-clojure.core> (p144 3 inc dec)
#<core$p144$ocil__4538 four_clojure.core$p144$ocil__4538@1ec69c8e>
four-clojure.core> (defn p144
  [x & f]
  ((fn ocil
    [x f1 & f]
    (if f1
      (cons x (lazy-seq (ocil (f1 x) f)))
      [x])) x f))

#'four-clojure.core/p144
four-clojure.core> (p144 3 inc dec)
ClassCastException clojure.lang.ArraySeq cannot be cast to clojure.lang.IFn  four-clojure.core/p144/ocil--4545/fn--4546 (form-init1677612859217766242.clj:6)
four-clojure.core> (defn p144
  [x & f]
  ((fn ocil
    [x [f1 & f]]
    (if f1
      (cons x (lazy-seq (ocil (f1 x) f)))
      [x])) x f))
#'four-clojure.core/p144
four-clojure.core> (p144 3 inc dec)
(3 4 3)
four-clojure.core> (defn p144
  [x & f]
  ((fn ocil
    [x [f1 & f]]
    (if f1
      (cons x (lazy-seq (ocil (f1 x) f)))
      [x])) x (cycle f)))

#'four-clojure.core/p144
four-clojure.core> (take 10 (p144 3 inc dec))
(3 4 3 4 3 4 3 4 3 4)
four-clojure.core> (take 5 (p144 3 #(- % 3) #(+ 5 %)))
(3 0 5 2 7)
four-clojure.core> (take 4(filter odd? (range)))
(1 3 5 7)
four-clojure.core> (defn 150
  [x]
  (filter #(= (str %) (reverse (str %))) (iterate inc x)))

IllegalArgumentException First argument to defn must be a symbol  clojure.core/defn (core.clj:277)
four-clojure.core> (defn p150
  [x]
  (filter #(= (str %) (reverse (str %))) (iterate inc x)))
#'four-clojure.core/p150
four-clojure.core> (take 26 (p150 0))
four-clojure.core> (take 26 (iterate inc 1))
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)
four-clojure.core> (str 10)
"10"
four-clojure.core> (reverse *1)
(\0 \1)
four-clojure.core> (str *1)
"(\\0 \\1)"
four-clojure.core> (str 10)
"10"
four-clojure.core> (reverse *1)
(\0 \1)
four-clojure.core> (apply str *1)
"01"
four-clojure.core> (defn p150
  [x]
  (filter #(= (str %) (apply str (reverse (str %)))) (iterate inc x)))

#'four-clojure.core/p150
four-clojure.core> (take 26 (iterate inc 1))
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)
four-clojure.core> (take 26 (p150 0))
(0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161)
four-clojure.core> (take 16 (p150 162))
(171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323)
four-clojure.core> (take 100 ((fn p150
  [x]
  (map #(= (str %) (apply str (reverse (str %)))) (iterate inc x))) 0))
(0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323 333 343 353 363 373 383 393 404 414 424 434 444 454 464 474 484 494 505 515 525 535 545 555 565 575 585 595 606 616 626 636 646 656 666 676 686 696 707 717 727 737 747 757 767 777 787 797 808 818 828 838 848 858 868 878 888 898 909)
four-clojure.core> (defn p150
  [x]
  (filter #(= (str %) (apply str (reverse (str %)))) (iterate inc x)))
#'four-clojure.core/p150
four-clojure.core> (defn p150
  [x]
  (map #(= (str %) (apply str (reverse (str %)))) (iterate inc x)))
#'four-clojure.core/p150
four-clojure.core> (take 16 (p150 162))
(false false false false false false false false false true false false false false false false)
four-clojure.core> (defn p150
  [x]
  (keep #(= (str %) (apply str (reverse (str %)))) (iterate inc x)))
#'four-clojure.core/p150
four-clojure.core> (take 16 (p150 162))
(false false false false false false false false false true false false false false false false)
four-clojure.core> (defn p150
  [x]
  (filter #(= (str %) (apply str (reverse (str %)))) (iterate inc x)))
#'four-clojure.core/p150
four-clojure.core> (take 16 (p150 162))
(171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323)
four-clojure.core> 
  (take 26 ((fn [x] (filter #(= (str %) (apply str (reverse (str %)))) (iterate inc x)) ) 0))
(0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161)
four-clojure.core> (defn gcd
  [n m]
  (if (zero? n) 
    m 
    (recur (rem m n) n)))

#'four-clojure.core/gcd
four-clojure.core> (gcd 10 10)
10
four-clojure.core> (gcd 10 9)
1
four-clojure.core> (gcd 10 1)
1
four-clojure.core> (gcd 10 2)
2
four-clojure.core> (map #(gcd 10 %) (range 10))
(10 1 2 1 2 5 2 1 2 1)
four-clojure.core> (map #(gcd 10 %) (range 1 10))
(1 2 1 2 5 2 1 2 1)
four-clojure.core> (map #(gcd 10 %) (range 1 10))
(1 2 1 2 5 2 1 2 1)
four-clojure.core> (gcd 1 1)
1
four-clojure.core> (map #(gcd 40 %) (range 1 40))
(1 2 1 4 5 2 1 8 1 10 1 4 1 2 5 8 1 2 1 20 1 2 1 8 5 2 1 4 1 10 1 8 1 2 5 4 1 2 1)
four-clojure.core> (defn p75
  [x]
  (filter #(= 1 (gcd x %)) (range 1 x)))

#'four-clojure.core/p75
four-clojure.core> (p75 10)
(1 3 7 9)
four-clojure.core> 
(defn p75
  [x]
  (count (filter #(= 1 ((fn 
                          [n m]
                          (if (zero? n) 
                            m 
                            (recur (rem m n) n))) x %)) (range 1 x))))
#'four-clojure.core/p75
four-clojure.core> (p75 10)
4
four-clojure.core> (p75 99)
60
four-clojure.core> (p75 1)
0
four-clojure.core> (p75 99)
60
four-clojure.core> (gcd 1 1)
1
four-clojure.core> (def a [[:e :e :e]
            [:e :e :e]
            [:e :e :e]])
#'four-clojure.core/a
four-clojure.core> a
[[:e :e :e] [:e :e :e] [:e :e :e]]
four-clojure.core> (get 1 3 a)
[[:e :e :e] [:e :e :e] [:e :e :e]]
four-clojure.core> (get-in a [0 0])
:e
four-clojure.core> (get-in a [0 1])
:e
four-clojure.core> (get-in a [0 2])
:e
four-clojure.core> (def a [[:e :o :e]
            [:e :o :e]
            [:e :o :e]])
#'four-clojure.core/a
four-clojure.core> (get-in a [0 2])
:e
four-clojure.core> (get-in a [0 0])
:e
four-clojure.core> (get-in a [0 1])
:o
four-clojure.core> (def a [[:x :o :e]
            [:e :x :e]
            [:e :o :x]])
#'four-clojure.core/a
four-clojure.core> (get-in a [0 0])
:x
four-clojure.core> (get-in a [1 1])
:x
four-clojure.core> (get-in a [2 2])
:x
four-clojure.core> (get-in a [2 2] [2 2])
:x
four-clojure.core> (get-in a [2 2] [1 2])
:x
four-clojure.core> (map #(get-in a %) [0 1] [1 1] [2 1])
ArityException Wrong number of args (3) passed to: core/eval4729/fn--4730  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (map #(get-in a %) [[0 1] [1 1] [2 1]])
(:o :x :o)
four-clojure.core> (map list 1 [1 2 3])
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (map list [1] [1 2 3])
((1 1))
four-clojure.core> (map list (cycle [1]) [1 2 3])
((1 1) (1 2) (1 3))
four-clojure.core> (for [x 1 y [1 2 3]] [x y])
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (for [x [1] y [1 2 3]] [x y])
([1 1] [1 2] [1 3])
four-clojure.core> (for [x [1 2 3] y [1 2 3]] [x y])
([1 1] [1 2] [1 3] [2 1] [2 2] [2 3] [3 1] [3 2] [3 3])
four-clojure.core> (map (list %1 %2) [1 1 1] [1 2 3])
CompilerException java.lang.RuntimeException: Unable to resolve symbol: %1 in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:6) 
four-clojure.core> (map #(list %1 %2) [1 1 1] [1 2 3])
((1 1) (1 2) (1 3))
four-clojure.core> (for [x [1 1 1] y [1 2 3]] [x y])
([1 1] [1 2] [1 3] [1 1] [1 2] [1 3] [1 1] [1 2] [1 3])
four-clojure.core> (for [x [3 2 1] y [1 2 3]] [x y])
([3 1] [3 2] [3 3] [2 1] [2 2] [2 3] [1 1] [1 2] [1 3])
four-clojure.core> (map #(list %1 %2) (cycle [1]) [1 2 3])
((1 1) (1 2) (1 3))
four-clojure.core> (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)))
four-clojure.core> (map (fn [x] (map #(list %1 %2)  (range 3) (cycle [x]))) (range 3))
(((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2)))
four-clojure.core> (map #(list %1 %2) (cycle 0) (range 3))
IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (map #(list %1 %2) (cycle [0]) (range 3))
((0 0) (0 1) (0 2))
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))]
    [hor ver dia1 dia2]))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
[(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2))) (((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2))) ((0 0) (1 1) (2 2)) ((0 2) (1 1) (2 0))]
four-clojure.core> (apply concat *1)
(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)) ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2)) (0 0) (1 1) (2 2) (0 2) (1 1) (2 0))
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))]
    [hor ver (concat dia1 dia2)]))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
[(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2))) (((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2))) ((0 0) (1 1) (2 2) (0 2) (1 1) (2 0))]
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))]
    [(conj (concat hor ver)  dia1 dia2)]))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
[(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)) ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2))) ((0 0) (1 1) (2 2) (0 2) (1 1) (2 0))]
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))]
    [(conj (concat hor ver)  dia1 dia2)]))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
[(((0 2) (1 1) (2 0)) ((0 0) (1 1) (2 2)) ((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)) ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2)))]
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver)  dia1 dia2)]
    all))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
(((0 2) (1 1) (2 0)) ((0 0) (1 1) (2 2)) ((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)) ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2)))
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver)  dia1 dia2)]
    (map (fn [coll] (map #(get-in %)) coll) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
ArityException Wrong number of args (1) passed to: core/map  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver)  dia1 dia2)]
    (map (fn [l] (map #(get-in coll %)) l) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
ArityException Wrong number of args (1) passed to: core/map  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> a
[[:x :o :e] [:e :x :e] [:e :o :x]]
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (map (fn [l] (map #(get-in coll %)) l) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
ArityException Wrong number of args (1) passed to: core/map  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    all))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
(((0 2) (1 1) (2 0)) ((0 0) (1 1) (2 2)) ((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2)) ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2)))
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (map (fn [l] (map #(get-in coll %) l)) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
((:e :x :e) (:x :x :x) (:x :o :e) (:e :x :e) (:e :o :x) (:x :e :e) (:o :x :o) (:e :e :x))
four-clojure.core> (map every? *1)
ArityException Wrong number of args (1) passed to: core/every?  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (map every? *1 :e)
IllegalArgumentException Don't know how to create ISeq from: clojure.lang.Keyword  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (map every? :e *1)
IllegalArgumentException Don't know how to create ISeq from: clojure.lang.Keyword  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (map every? :x (second *1))
IllegalArgumentException Don't know how to create ISeq from: clojure.lang.Keyword  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (every? :a [:a :a])
false
four-clojure.core> (every? :a [:a :a 1])
false
four-clojure.core> (def b (p73 a))
#'four-clojure.core/b
four-clojure.core> b
((:e :x :e) (:x :x :x) (:x :o :e) (:e :x :e) (:e :o :x) (:x :e :e) (:o :x :o) (:e :e :x))
four-clojure.core> (filter #(apply = %) b)
((:x :x :x))
four-clojure.core> (filter #(apply = % :x) b)
IllegalArgumentException Don't know how to create ISeq from: clojure.lang.Keyword  clojure.lang.RT.seqFrom (RT.java:505)
four-clojure.core> (every? 1 [1 1 1])
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  clojure.core/every? (core.clj:2495)
four-clojure.core> (every? #(= 1 %) [1 1 1])
true
four-clojure.core> (every? #(= :x %) [1 1 1])
false
four-clojure.core> b
((:e :x :e) (:x :x :x) (:x :o :e) (:e :x :e) (:e :o :x) (:x :e :e) (:o :x :o) (:e :e :x))
four-clojure.core> (map (every? #(= :x %)) b)
ArityException Wrong number of args (1) passed to: core/every?  clojure.lang.AFn.throwArity (AFn.java:429)
four-clojure.core> (map (fn [l] (every? #(= :x %) l)) b)
(false true false false false false false false)
four-clojure.core> (filter #(apply = %) b)
((:x :x :x))
four-clojure.core> (filter #(if (apply = %)
			      %) b)
((:x :x :x))
four-clojure.core> (filter #(if (apply = %)
			      (if (= (first %) :x)
				:x)) b)
((:x :x :x))
four-clojure.core> (if (= 1 (or 1 5)))
CompilerException java.lang.RuntimeException: Too few arguments to if, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (if (= 1 (or 1 5)) 1 2)
1
four-clojure.core> (if (= 1 (or 2 5)) 1 2)
2
four-clojure.core> (filter #(if (apply = %)
			      (if (= (first %) (or :x :o))
				(first %)
				nil)) b)
((:x :x :x))
four-clojure.core> (map #(if (apply = %)
			      (if (= (first %) (or :x :o))
				(first %)
				nil)) b)
(nil :x nil nil nil nil nil nil)
four-clojure.core> (keep #(if (apply = %)
			      (if (= (first %) (or :x :o))
				(first %)
				nil)) b)
(:x)
four-clojure.core> 
four-clojure.core> (keep #(if (apply = %)
			      (if (= (first %) (or :x :o))
				(first %)
				nil)) b)
(:x)
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (map (fn [l]
           (let [end (map #(get-in coll %) l)]
             (if (apply = end)
               (if (= (first end) (or :x :o))
                 (first end)
                 nil)))) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
(nil :x nil nil nil nil nil nil)
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (keep (fn [l]
            (let [end (map #(get-in coll %) l)]
              (if (apply = end)
                (if (= (first end) (or :x :o))
                  (first end)
                  nil)))) all)))
#'four-clojure.core/p73
four-clojure.core> (p73 a)
(:x)
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (first
     (keep (fn [l]
             (let [end (map #(get-in coll %) l)]
               (if (apply = end)
                 (if (= (first end) (or :x :o))
                   (first end)
                   nil)))) all))))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
:x
four-clojure.core> (def a [[:e :x :e]
           [:o :o :o]
           [:x :e :x]])
#'four-clojure.core/a
four-clojure.core> (p73 a)
nil
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (map (fn [l] (map #(get-in coll %) l)) all)))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
((:e :o :x) (:e :o :x) (:e :x :e) (:o :o :o) (:x :e :x) (:e :o :x) (:x :o :e) (:e :o :x))
four-clojure.core> (map (fn [l] (apply = l)) *1)
(false false false true false false false false)
four-clojure.core> (p73 a)
((:e :o :x) (:e :o :x) (:e :x :e) (:o :o :o) (:x :e :x) (:e :o :x) (:x :o :e) (:e :o :x))
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
     (keep (fn [l]
             (let [end (map #(get-in coll %) l)]
               (if (apply = end)
                 (if (= (first end) (or :x :o))
                   (first end)
                   nil)))) all)))
#'four-clojure.core/p73
four-clojure.core> (p73 a)
()
four-clojure.core> (if (= 1 (or 0 1)) "anjing" "babi")
"babi"
four-clojure.core> (defn p73
  [coll]
  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))
        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))
        dia1 (map #(list %1 %2) (range 3) (range 3))
        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))
        all (conj (concat hor ver) dia1 dia2)]
    (first
     (keep (fn [l]
             (let [end (map #(get-in coll %) l)]
               (if (apply = end)
                 (if (or (= (first end) :x) (= (first end) :o))
                   (first end)
                   nil)))) all))))

#'four-clojure.core/p73
four-clojure.core> (p73 a)
:o
four-clojure.core> (flatten [[1 2 3]])
(1 2 3)
four-clojure.core> (flatten [[1 2 3 [1 2 3]]])
(1 2 3 1 2 3)
four-clojure.core> (map flatten [[1 2 3 [1 2 3]]])
((1 2 3 1 2 3))
four-clojure.core> (defn p79
  [x y coll]
  (if (get-in coll [(inc x) y])
    (+ (get-in coll [x y])
       (min (p79 (inc x) y coll)
            (p79 (inc x) (inc y) coll)))
    (get-in coll [x y])))

#'four-clojure.core/p79
four-clojure.core> (def a 
		     '([1]
          [2 4]
         [5 1 4]
        [2 3 4 5]))
#'four-clojure.core/a
four-clojure.core> a
([1] [2 4] [5 1 4] [2 3 4 5])
four-clojure.core> (p79 0 0 a)
nil
four-clojure.core> (defn p79
  [x y coll]
  (if (get-in coll [(inc x) y])
    (+ (get-in coll [x y])
       (max (p79 (inc x) y coll)
            (p79 (inc x) (inc y) coll)))
    (get-in coll [x y])))

#'four-clojure.core/p79
four-clojure.core> (p79 0 0 a)
nil
four-clojure.core> a
([1] [2 4] [5 1 4] [2 3 4 5])
four-clojure.core> a
([1] [2 4] [5 1 4] [2 3 4 5])
four-clojure.core> (get-in coll [0 0])
CompilerException java.lang.RuntimeException: Unable to resolve symbol: coll in this context, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (get-in a [0 0])
nil
four-clojure.core> (get-in (vec a) [0 0])
1
four-clojure.core> (p79 0 0 (vec a))
14
four-clojure.core> (defn p79
  [x y coll]
  (if (get-in coll [(inc x) y])
    (+ (get-in coll [x y])
       (min (p79 (inc x) y coll)
            (p79 (inc x) (inc y) coll)))
    (get-in coll [x y])))

#'four-clojure.core/p79
four-clojure.core> (p79 0 0 (vec a))
7
four-clojure.core> ((fn p79
  [x y coll]
  (if (get-in coll [(inc x) y])
    (+ (get-in coll [x y])
       (min (p79 (inc x) y coll)
            (p79 (inc x) (inc y) coll)))
    (get-in coll [x y]))) 0 0 (vec a))

7
four-clojure.core> (#((fn p79
  [x y coll]
  (if (get-in coll [(inc x) y])
    (+ (get-in coll [x y])
       (min (p79 (inc x) y coll)
            (p79 (inc x) (inc y) coll)))
    (get-in coll [x y]))) 0 0 (vec %)) a)

7
four-clojure.core> (defn p98
  [f coll]
  (map f coll))
#'four-clojure.core/p98
four-clojure.core> (def f #(* % %))
#'four-clojure.core/f
four-clojure.core> (def a #{-2 -1 0 1 2})
#'four-clojure.core/a
four-clojure.core> (p98 f a)
(0 1 4 1 4)
four-clojure.core> (defn p98
  [f coll]
  (group-by f coll))
#'four-clojure.core/p98
four-clojure.core> (p98 f a)
{0 [0], 1 [1 -1], 4 [-2 2]}
four-clojure.core> (def b *1)
#'four-clojure.core/b
four-clojure.core> b
{0 [0], 1 [1 -1], 4 [-2 2]}
four-clojure.core> (map #(into #{} (val %)) b)
(#{0} #{1 -1} #{-2 2})
four-clojure.core> (set (map #(into #{} (val %)) b))
#{#{1 -1} #{-2 2} #{0}}
four-clojure.core> (defn p98
  [f coll]
  (set (map #(into #{} (val %)) (group-by f coll))))

#'four-clojure.core/p98
four-clojure.core> (p98 f a)
#{#{1 -1} #{-2 2} #{0}}
four-clojure.core> '{b 13 a 14}
{b 13, a 14}
four-clojure.core> ('b *1)
13
four-clojure.core> '(/ a b)
(/ a b)
four-clojure.core> (eval *1)
ClassCastException clojure.lang.PersistentArrayMap cannot be cast to java.lang.Number  clojure.lang.Numbers.divide (Numbers.java:155)
four-clojure.core> (def f '(/ a b))
#'four-clojure.core/f
four-clojure.core> f
(/ a b)
four-clojure.core> f
(/ a b)
four-clojure.core> '(/ 4 5)
(/ 4 5)
four-clojure.core> (eval *1)
4/5
four-clojure.core> f
(/ a b)
four-clojure.core> 
four-clojure.core> (second *1)
a
four-clojure.core> (def a 1)
#'four-clojure.core/a
four-clojure.core> (def b 2)
#'four-clojure.core/b
four-clojure.core> (eval f)
1/2
four-clojure.core> (defn p121
  [f m]
  (do (def a ('a m))
      (def b ('b m)))
  (eval f))

#'four-clojure.core/p121
four-clojure.core> (p121 '(/ a b) '{b 8 a 16})
2
four-clojure.core> (defn p121
  [f]
  (fn [m]
    (do (def a ('a m))
        (def b ('b m)))
    (eval f)))
#'four-clojure.core/p121
four-clojure.core> ((p121 '(/ a b))
      '{b 8 a 16})
2
four-clojure.core> f
(/ a b)
four-clojure.core> ((first f) 2 3)
3
four-clojure.core> (first f)
/
four-clojure.core> (list / 1 2)
(#<core$_SLASH_ clojure.core$_SLASH_@2e649671> 1 2)
four-clojure.core> (eval *1)
1/2
four-clojure.core> (#(% 2 3) (first f))
3
four-clojure.core> (/ 2 3)
2/3
four-clojure.core> 1234
1234
four-clojure.core> (quot 1000) 
CompilerException clojure.lang.ArityException: Wrong number of args (1) passed to: core/quot--inliner, compiling:(C:\Users\Calvin\AppData\Local\Temp\form-init1677612859217766242.clj:1:1) 
four-clojure.core> (quot 1000 1234) 
0
four-clojure.core> (rem 1000 1234) 
1000
four-clojure.core> (rem 1000 1234) 
1000
four-clojure.core> (rem 100 1234) 
100
four-clojure.core> (rem 1234 1000) 
234
four-clojure.core> (rem 1234 10000) 
1234
four-clojure.core> (rem 1234 1000) 
234
four-clojure.core> (rem 1234 1000) 